use std::str::FromStr;
use super::{Ast, Span};
use std::boxed::Box;
use typed_arena::Arena;
use vm::{SymbolIntern, Symbol};

grammar<'a>(arena: &'a Arena<Ast<'a>>, interner: &mut SymbolIntern)["LALR(1)"];

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e { 
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Expr: Ast<'a> = {
     <l:Expr> "+" <r:Factor>  =>
        Ast::Add(arena.alloc(l), arena.alloc(r), Span(0, 0)),
     <l:Expr> "-" <r:Factor>  =>
        Ast::Sub(arena.alloc(l), arena.alloc(r), Span(0, 0)),
    Closure,
    FunctionCall,
    IfExpression,
    Factor,
};

Factor: Ast<'a> = {
     <l:Factor> "*" <r:Term>  =>
        Ast::Mul(arena.alloc(l), arena.alloc(r), Span(0, 0)),
     <l:Factor> "/" <r:Term>  =>
        Ast::Div(arena.alloc(l), arena.alloc(r), Span(0, 0)),
    Reserved,
};

Reserved: Ast<'a> = {
    Term,
};

Term: Ast<'a> = {
    FloatLit,
    IntLit,
    StringLit,
    SymbolLit,
     Identifier  => Ast::Identifier(<>, Span(0, 0)),
    "(" <Expr> ")" 
};

Statement: Ast<'a> = {
    <e: Expr> ";" => e
};

IfExpression: Ast<'a> = {
    "if" <cond: Expr> "then" "{" <tru: Expr> "}" "else" "{" <fals: Expr> "}" =>
        Ast::IfExpression(arena.alloc(cond),
                          arena.alloc(tru),
                          arena.alloc(fals),
                          Span(0, 0))
};

Closure: Ast<'a> = {
     "fn" <name: Identifier?> <p_list: ParamList+> "{" "}"  =>
        Ast::Closure(name, p_list, vec![], Span(0, 0)),

};

ParamList: Vec<Symbol> = {
    "(" <params: Comma<Identifier>> ")" => params,
};

FunctionCall: Ast<'a> = {
     <recv: Expr> "(" <args: Comma<Expr>> ")"  =>
    Ast::FnCall(arena.alloc(recv), args, Span(0, 0)),
};

IntLit: Ast<'a> = {
     <int: r"[0-9]+">  =>
        Ast::IntLit(i64::from_str(int).unwrap(), Span(0, 0))
};

FloatLit: Ast<'a> = {
     <float: r"[0-9]+\.[0-9]*">  =>
        Ast::FloatLit(f64::from_str(float).unwrap(), Span(0, 0))
};

StringLit: Ast<'a> = {
     <string: r##""(\\.|[^"])*""##>  =>
        Ast::StringLit(string[1 .. string.len() - 1].into(), Span(0, 0))
};

SymbolLit: Ast<'a> = {
    <symbol: r"'[_a-zA-Z][_a-zA-Z0-9]*">  =>
       Ast::SymbolLit(interner.intern(&symbol[1..]), Span(0, 0))
};

Identifier: Symbol = {
    r"[_a-zA-Z][_a-zA-Z0-9]*" => interner.intern(<>)
};
