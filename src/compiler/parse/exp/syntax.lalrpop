use std::str::FromStr;
use super::{Ast, Span};
use std::boxed::Box;
use typed_arena::Arena;
use vm::{SymbolIntern, Symbol};

grammar<'a>(arena: &'a Arena<Ast<'a>>, interner: &mut SymbolIntern)["LALR(1)"];

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e { 
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

PrimaryExpression: Ast<'a> = {
    FloatLit,
    IntLit,
    StringLit,
    SymbolLit,
    Identifier  => Ast::Identifier(<>, Span(0, 0)),
    "(" <e: Expr> ")" => e,
};

PostfixExpression: Ast<'a> = {
    PrimaryExpression,
    <r: PostfixExpression> "[" <e: Expr> "]" => unimplemented!(),
    <r: PostfixExpression> "(" <e: Expr*> ")" => unimplemented!(),
    <r: PostfixExpression> "." <e: Identifier> => unimplemented!(),
};

UnaryExpression: Ast<'a> = {
    PostfixExpression,
    "-" <e: UnaryExpression> => unimplemented!(),
    "+" <e: UnaryExpression> => unimplemented!(),
    "~" <e: UnaryExpression> => unimplemented!(),
    "!" <e: UnaryExpression> => unimplemented!(),
};

MultiplicativeExpression: Ast<'a> = {
    UnaryExpression,
    <l: MultiplicativeExpression> "*" <r: UnaryExpression> =>
        Ast::Mul(arena.alloc(l), arena.alloc(r)),
    <l: MultiplicativeExpression> "/" <r: UnaryExpression> =>
        Ast::Div(arena.alloc(l), arena.alloc(r)),
    <l: MultiplicativeExpression> "%" <r: UnaryExpression> =>
        unimplemented!()
};

AdditiveExpression: Ast<'a> = {
    MultiplicativeExpression,
    <l: AdditiveExpression> "+" <r: MultiplicativeExpression> =>
        Ast::Add(arena.alloc(l), arena.alloc(r)),
    <l: AdditiveExpression> "-" <r: MultiplicativeExpression> =>
        Ast::Sub(arena.alloc(l), arena.alloc(r)),
};

ShiftExpression: Ast<'a> = {
    AdditiveExpression,
    <l: ShiftExpression> "<<" <r: AdditiveExpression> =>
        unimplemented!(),
    <l: ShiftExpression> ">>" <r: AdditiveExpression> =>
        unimplemented!(),
};

RelationalExpression: Ast<'a> = {
    ShiftExpression,
    <l: RelationalExpression> ">" <r: ShiftExpression> => unimplemented!(),
    <l: RelationalExpression> "<" <r: ShiftExpression> => unimplemented!(),
    <l: RelationalExpression> ">=" <r: ShiftExpression> => unimplemented!(),
    <l: RelationalExpression> "<=" <r: ShiftExpression> => unimplemented!(),
};

EqualityExpression: Ast<'a> = {
    RelationalExpression,
    <l: EqualityExpression> "==" <r: RelationalExpression> => unimplemented!(),
    <l: EqualityExpression> "!=" <r: RelationalExpression> => unimplemented!(),
};

BitAndExpression: Ast<'a> = {
    EqualityExpression,
    <l: BitAndExpression> "&" <r: EqualityExpression> => unimplemented!(),
};

BitXorExpression: Ast<'a> = {
    BitAndExpression,
    <l: BitXorExpression> "^" <r: BitAndExpression> => unimplemented!(),
};

BitOrExpression: Ast<'a> = {
    BitXorExpression,
    <l: BitOrExpression> "|" <r: BitXorExpression> => unimplemented!(),
};

LogicalAndExpression: Ast<'a> = {
    BitOrExpression,
    <l: LogicalAndExpression> "&&" <r: BitOrExpression> => unimplemented!(),
};

LogicalOrExpression: Ast<'a> = {
    LogicalAndExpression,
    <l: LogicalOrExpression> "||" <r: LogicalAndExpression> => unimplemented!(),
};

IfExpression: Ast<'a> = {
    LogicalOrExpression,
    <a: LogicalOrExpression> "?" <t: Expr> ":" <f: IfExpression> => unimplemented!(),
};

AssignmentExpression: Ast<'a> = {
    IfExpression,
    <r: PostfixExpression> "=" <l: AssignmentExpression> => unimplemented!(),
};

pub Expr: Ast<'a> = {
    AssignmentExpression
};

Statement: Ast<'a> = {
    "if" <cond: Expr> "then" "{" <trus: Statement*> "}" =>
        Ast::IfStatement(arena.alloc(cond),
                          arena.alloc(trus),
                          None,
                          Span(0, 0)),
    "if" <cond: Expr> "then" "{" <trus: Statement*> "}" "else" "{" <falss: Statement*> "}" =>
        Ast::IfStatement(arena.alloc(cond),
                          arena.alloc(trus),
                          arena.alloc(falss),
                          Span(0, 0)),
};

Closure: Ast<'a> = {
     "fn" <name: Identifier?> <p_list: ParamList+> "{" <bodies: Statement*> "}"  =>
        Ast::Closure(name, p_list, vec![], Span(0, 0)),

};

ParamList: Vec<Symbol> = {
    "(" <params: Comma<Identifier>> ")" => params,
};

IntLit: Ast<'a> = {
     <int: r"[0-9]+">  =>
        Ast::IntLit(i64::from_str(int).unwrap(), Span(0, 0))
};

FloatLit: Ast<'a> = {
     <float: r"[0-9]+\.[0-9]*">  =>
        Ast::FloatLit(f64::from_str(float).unwrap(), Span(0, 0))
};

StringLit: Ast<'a> = {
     <string: r##""(\\.|[^"])*""##>  =>
        Ast::StringLit(string[1 .. string.len() - 1].into(), Span(0, 0))
};

SymbolLit: Ast<'a> = {
    <symbol: r"'[_a-zA-Z][_a-zA-Z0-9]*">  =>
       Ast::SymbolLit(interner.intern(&symbol[1..]), Span(0, 0))
};

Identifier: Symbol = {
    r"[_a-zA-Z][_a-zA-Z0-9]*" => interner.intern(<>)
};
